#!/usr/bin/env python

import sys
sys.path.append('@CMAKE_SOURCE_DIR@/examples/') # to access sgutils

from ctypes import CDLL, c_double, c_int, c_void_p, byref, POINTER
import numpy
import argparse
from numpy import pi, sin, cos, tan, exp, log
import sgutils

# parse input arguments

parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument('--dims', dest='dims', default='3,5',
                    help='Number of nodes in x and y')
parser.add_argument('--xmin', dest='xmin', default='0.0,0.0',
                    help='Min domain corner')
parser.add_argument('--xmax', dest='xmax', default='1.0,1.0',
                    help='Max domain corner')
parser.add_argument('--n', dest='n', type=int, default=10,
                    help='Number of line segments')
parser.add_argument('--xline', dest='xline', default='xmin[0] + (xmax[0] - xmin[0])*t',
                    help='X coordinate parametric representation of line as a function of t, 0 <= t <= 1')
parser.add_argument('--yline', dest='yline', default='xmin[1] + (xmax[1] - xmin[1])*t',
                    help='Y coordinate parametric representation of line as a function of t, 0 <= t <= 1')
parser.add_argument('--psi', dest='psi', default='0.5*(x**2 + cos(2*pi*y)/pi)',
                    help='Stream function of x and y')
args = parser.parse_args()

# create structured grid and field
dims = numpy.array(eval(args.dims), numpy.int32)
xmin = numpy.array(eval(args.xmin), numpy.float64)
xmax = numpy.array(eval(args.xmax), numpy.float64)
coords = sgutils.createRectilinearGrid(dims, xmin, xmax)

# create line
n = args.n
t = numpy.linspace(0., 1., n + 1)
dstX, dstY = eval(args.xline), eval(args.yline)
print dstX
print dstY

# project online 
sg = CDLL("@CMAKE_BINARY_DIR@/cpp/libsigrid@CMAKE_SHARED_LIBRARY_SUFFIX@")
this = c_void_p()

ier = sg.SgFlowInterp2D_new(byref(this))
assert(ier == 0)

srcCoords = (POINTER(c_double) * 2)(coords[0].ctypes.data_as(POINTER(c_double)),
                                    coords[1].ctypes.data_as(POINTER(c_double)))
ier = sg.SgFlowInterp2D_setSrcGrid(byref(this), dims.ctypes.data_as(POINTER(c_int)), srcCoords)
assert(ier == 0)

dstDims = (c_int*1)(n + 1)
dstCoords = (POINTER(c_double) * 2)(dstX.ctypes.data_as(POINTER(c_double)), dstY.ctypes.data_as(POINTER(c_double)))
ier = sg.SgFlowInterp2D_setDstGrid(byref(this), dstDims, dstCoords)
assert(ier == 0)

ier = sg.SgFlowInterp2D_computeWeights(byref(this))
assert(ier == 0)

x = coords[0]
y = coords[1]
psi = eval(args.psi)

# integrated flux
srcXFlux = -(psi[1:, :] - psi[:-1, :])
srcYFlux = +(psi[:, 1:] - psi[:, :-1])
srcData = (POINTER(c_double) * 2)(srcXFlux.ctypes.data_as(POINTER(c_double)), srcYFlux.ctypes.data_as(POINTER(c_double)))
dstData = numpy.zeros((n,), numpy.float64) # to be filled in
sg.SgFlowInterp2D_apply(byref(this), srcData, dstData.ctypes.data_as(POINTER(c_double)))
sg.SgFlowInterp2D_debug(byref(this))
sg.SgFlowInterp2D_del(byref(this))

t = 0.0
x, y = eval(args.xline), eval(args.yline)
psia = eval(args.psi)
t = 1.0
x, y = eval(args.xline), eval(args.yline)
psib = eval(args.psi)
exact = psia - psib
approx = dstData.sum()
print('integrated flux: {} exact: {} error = {}'.format(approx, exact, approx - exact))

sgutils.saveStreamlinesVtk('streamFlow.vtk', coords, psi)
sgutils.saveLineVtk('streamLine.vtk', (dstX, dstY), dstData)
