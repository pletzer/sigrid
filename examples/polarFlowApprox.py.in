#!/usr/bin/env python

import sys
sys.path.append('@CMAKE_SOURCE_DIR@/examples/') # to access sgutils

from ctypes import CDLL, c_double, c_int, c_void_p, byref, POINTER
import numpy
import math
import argparse
from numpy import pi, sin, cos, tan, exp, log
import sgutils

# parse input arguments

parser = argparse.ArgumentParser(description='Generate polar flow.')
parser.add_argument('--dims', dest='dims', default='21,11',
                    help='Number of nodes in rho and theta')
parser.add_argument('--radius', dest='radius', default=1.0, type=float,
                    help='Min domain corner')
parser.add_argument('--n', dest='n', type=int, default=4,
                    help='Number of line segments')
parser.add_argument('--xline', dest='xline', default='0.5*radius*cos(2*pi*t)',
                    help='X coordinate parametric representation of line as a function of t, 0 <= t <= 1')
parser.add_argument('--yline', dest='yline', default='0.5*radius*sin(2*pi*t)',
                    help='Y coordinate parametric representation of line as a function of t, 0 <= t <= 1')
args = parser.parse_args()

# create structured grid and field
dims = numpy.array(eval(args.dims), numpy.int32)
radius = args.radius
coords = sgutils.createPolarGrid(dims, radius)

# create line
n = args.n
t = numpy.linspace(0., 1., n + 1)
dstX, dstY = eval(args.xline), eval(args.yline)
print('Target parametric equation:')
print('x = {}'.format(args.xline))
print('y = {}'.format(args.yline))
print('positions: {}'.format([(dstX[i], dstY[i]) for i in range(len(dstX))]))

# create mid point values and deltas
numSegs = len(dstX) - 1
dstXMid = numpy.array([0.5*(dstX[i+1] + dstX[i]) for i in range(numSegs)])
dstYMid = numpy.array([0.5*(dstY[i+1] + dstY[i]) for i in range(numSegs)])
dstXDif = numpy.array([dstX[i+1] - dstX[i] for i in range(numSegs)])
dstXDif = numpy.array([dstY[i+1] - dstY[i] for i in range(numSegs)])

# 
# interpolate the grid to the dstXMid,dstYMid points
#
fluxes = numpy.zeros((numSegs,), numpy.float64)

# project online 
sg = CDLL("@CMAKE_BINARY_DIR@/cpp/libsigrid@CMAKE_SHARED_LIBRARY_SUFFIX@")
this = c_void_p()

nitermax = 100
tolpos = c_double(1.e-12)

# initial guess for the index position
dInds = numpy.array([int(dims[0]/1.89), int(dims[1]/2.32)])
targetPoints = numpy.array([0., 0.])

ier = sg.SgFindPointInCell_new(byref(this), nitermax, tolpos)
assert(ier == 0)

# set the grid coordinates
srcCoords = (POINTER(c_double) * 2)(coords[0].ctypes.data_as(POINTER(c_double)),
                                    coords[1].ctypes.data_as(POINTER(c_double)))
ier = sg.SgFindPointInCell_setGrid(byref(this), 2, dims.ctypes.data_as(POINTER(c_int)), srcCoords)

# set the vector field in Cartesian coordinates
xx, yy = coords[0], coords[1]
rr2 = xx**2 + yy**2
vxx = xx/(2. * math.pi * rr2)
vyy = yy/(2. * math.pi * rr2)

for i in range(numSegs):

	targetPoint[:] = dstXMid[i], dstYMid[i]
	ier = sg.SgFlowInterp2D_reset(byref(this), 
		                          dInds.ctypes.data_as(POINTER(c_double)), 
		                          targetPoint.ctypes.data_as(POINTER(c_double)))

	# find the index position corresponding to the target
	end = 0
	while end == 0:
		end = sg.SgFlowInterp2D_next(byref(this))
	assert(end == 1)
	ier = sg.SgFlowInterp2D_getIndices(byref(this), 
		                               dInds.ctypes.data_as(POINTER(c_double)))
	assert(ier == 0)

	ij00 = numpy.array([math.floor(dInds[0]), math.floor(dInds[1])])
	ij10 = (ij00[0] + 1, ij00 + 0)
	ij11 = (ij00[0] + 1, ij00 + 1)
	ij01 = (ij00[0] + 0, ij00 + 1)

	# compute the weights
	xi = dInds - ij00
	w00 = (1. - xi[0])*(1. - xi[1])
	w10 = xi[0]*(1. - xi[1])
	w11 = xi[0]*xi[1]
	w01 = (1. - xi[0])*xi[1]

	# interpolate
	vx = w00*vxx[ij00] + w10*vxx[ij10] + w11*vxx[ij11] + w01*vxx[ij01]
	vy = w00*vyy[ij00] + w10*vyy[ij10] + w11*vyy[ij11] + w01*vyy[ij01]
	dx = dstXDif[i]
	dy = dstYDif[i]

	fluxes[i] = vx*dy - vy*dx

ier = sg.SgFindPointInCell_del(byref(this))

approx = fluxes.sum()
print('integrated flux: {}'.format(approx))
